<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Surah Walker</title>
  <link rel="manifest" href="manifest.json">
  <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32.png">
<link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16.png">
  <style>
    :root{
      --bg:#064e3b;        /* dark emerald */
      --gold:#ffd54a;      /* gold */
      --muted:#cbd5e1;     /* slate-ish */
      --muted2:#94a3b8;
    }
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    body{
      --bg-img-walk: url("assets/bg/beach_day_walk.png");
      --bg-img-pause: var(--bg-img-walk);
      background: var(--bg-img-walk);
      background-size: cover;
      background-position: center center;
      background-repeat: no-repeat;
      background-attachment: fixed;
      color:white;display:flex;align-items:center;justify-content:center;
      position:relative;
      overflow:hidden;
    }
    /* Slightly blur the background without affecting foreground text */
    body::after{
      content:"";
      position:fixed;
      inset:-2%;
      background: var(--bg-img-walk);
      background-size: cover;
      background-position: center center;
      background-repeat: no-repeat;
      background-attachment: fixed;
      filter: blur(2px);
      transform: scale(1.03);
      z-index:0;
      pointer-events:none;
    }

	body.resting {
      background: var(--bg-img-pause);
      background-size: cover;
      background-position: center center;
      background-repeat: no-repeat;
      background-attachment: fixed;
}

    .wrap{
      width:min(1100px, 92vw);
      height:100vh;
      position:relative;
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:1; /* keep content above blurred background layer */
    }
    .corner{
      position:fixed;
      top:calc(12px + env(safe-area-inset-top, 0px));
      left:50%;
      transform:translateX(-50%);
      padding:8px 12px;
      font-size:14px;
      color:#e2e8f0;
      letter-spacing:.2px;
      user-select:none;
      z-index:12000; /* keep progress visible above overlays */
      text-shadow:0 1px 6px rgba(0,0,0,0.45);
      background:rgba(0,0,0,0.32);
      border:1px solid rgba(255,255,255,0.18);
      border-radius:12px;
      cursor:pointer;
      transition:background .18s ease, border-color .18s ease;
    }
    .corner:hover{
      background:rgba(0,0,0,0.46);
      border-color:rgba(255,255,255,0.28);
    }
    .corner b{color:white;font-weight:650}
    .center{
      position:relative; /* allow content to center within .wrap */
      display:flex;flex-direction:column;align-items:center;justify-content:center;
      text-align:center;gap:18px;
      user-select:none;
      max-width:86vw;
      padding:48px 1px;
      padding-bottom:160px; /* leave room for bottom controls while lowering text into the plate */
    }
    /* Reading plate to keep text legible */
    .center::before{
      content:"";
      position:absolute;
      inset:0% 0% 30% 0%; /* trim the bottom so the plate doesn‚Äôt run to the edge */
      border-radius:28px;
      background:rgba(21, 69, 57, 0.404);
      border:1px solid rgba(255,255,255,0.12);
      backdrop-filter:blur(4px);
      pointer-events:none;
      z-index:0;
    }
    #cornerMenu{
      position:fixed;
      display:none;
      top:calc(12px + env(safe-area-inset-top, 0px));
      left:50%;
      transform:translateX(-50%);
      width:260px;
      background:rgba(0,0,0,0.16);
      border:1px solid rgba(255,255,255,0.18);
      border-radius:14px;
      padding:12px;
      z-index:13000;
      backdrop-filter:blur(4px);
      box-shadow:0 10px 30px rgba(0,0,0,0.35);
      color:#e2e8f0;
    }
    #cornerMenu h4{
      margin:2px 0 10px 0;
      font-size:16px;
      font-weight:700;
      letter-spacing:.2px;
      color:#f8fafc;
      text-align:left;
    }
    #cornerMenu .row{
      display:flex;
      gap:8px;
      margin-bottom:10px;
      align-items:center;
    }
    #cornerMenu input[type=number]{
      flex:1;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(0,0,0,0.12);
      color:#e2e8f0;
      font-size:14px;
      outline:none;
    }
    #cornerMenu button{
      width:100%;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(0,0,0,0.18);
      color:#e2e8f0;
      font-size:14px;
      cursor:pointer;
      transition:background .15s ease, border-color .15s ease;
    }
    #cornerMenu button:hover{
      background:rgba(0,0,0,0.28);
      border-color:rgba(255,255,255,0.28);
    }
    #cornerMenu .primary{
      width:auto;
      padding:10px 14px;
      white-space:nowrap;
    }
    .center > *{
      position:relative;
      z-index:1;
    }

    @media (min-width:1000px){
      .center{
        padding-top:72px;
        padding-bottom:200px;
      }
    }
    .arabic{
      font-size:56px;line-height:1.25;
      color:var(--gold);
      padding:0 10px;
      direction:rtl;
      font-family: "Amiri", "Scheherazade New", "Noto Naskh Arabic", serif;
      text-align:center;
      max-width:92vw;
      word-break:keep-all;
      /* reverted to simpler gold color for clarity */
      text-shadow: 0 6px 18px rgba(0,0,0,0.22);
      font-weight:600;
    }
    .subrow{
      margin-top:18px;
      display:flex;gap:14px;align-items:center;justify-content:center;
      color:var(--muted);
      font-size:16px;
      min-height:28px;
    }
    .pill{
      border:1px solid rgba(255,255,255,.18);
      border-radius:999px;
      padding:8px 14px;
      background:rgba(0,0,0,.12);
      cursor:pointer;
      user-select:none;
      font-size:16px;
      min-width:48px;
      height:48px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
    }
    .hint{
      position:fixed;bottom:120px;left:50%;transform:translateX(-50%);
      color:rgba(255,255,255,0.60);font-size:14px;z-index:9999;
      user-select:none;text-align:center;max-width:72%;line-height:1.4;opacity:0.95;
    }
    /* bottom-centered toggles pinned to viewport (avoid overlapping center content) */
    .subrow.toggles{ position:fixed; bottom:34px; left:50%; transform:translateX(-50%); gap:18px; z-index:10000; }

    #fullMean{ color:rgba(203,213,225,0.86); max-width:82%; font-size:16px; margin:12px auto 0; text-align:center; padding:0 18px; opacity:0.92; transition:opacity .18s ease, transform .18s ease; }
    #pron, #mean{ font-size:16px; color:rgba(203,213,225,0.78); margin-top:18px; opacity:0.9; transition:opacity .18s ease, transform .18s ease; position:relative; z-index:2000; }

    
    /* make assistant texts subtler on large screens */
    @media (min-width:1000px){
      #fullMean{ font-size:22px; opacity:0.88; }
      #pron, #mean{ font-size:20px; opacity:0.8; }
    }

    @media (min-width:1000px){
      .arabic{ font-size:120px; line-height:1.02; }
      #fullMean{ font-size:26px; max-width:72%; }
      #pron, #mean{ font-size:20px; }
      .pill{ padding:12px 18px; font-size:18px; min-width:60px; height:56px; }
      .wrap{ height:100vh; }
    }
    @media (min-width:1400px){
      .arabic{ font-size:160px; }
      #fullMean{ font-size:30px; }
    }

    .screen{
      position:absolute;inset:0;
      display:flex;flex-direction:column;align-items:center;justify-content:center;
      gap:18px;
    }
    .card{
      width:min(520px, 86vw);
      background:rgba(0,0,0,.14);
      border:1px solid rgba(255,255,255,.18);
      border-radius:20px;
      padding:18px 16px;
    }
    .title{
      font-size:20px;font-weight:700;letter-spacing:.2px;
      margin:0 0 6px 0;
    }
    .small{color:var(--muted);font-size:14px;margin:0}
    img.basmalah{
      max-width:280px;width:60%;
      height:auto;display:block;margin:0 auto 10px auto;
      filter: drop-shadow(0 8px 18px rgba(0,0,0,.25));
      border-radius:12px;
      background:rgba(255,255,255,.06);
      padding:10px;
    }
    .btn{
      display:inline-block;
      margin-top:10px;
      border:1px solid rgba(255,255,255,.22);
      border-radius:14px;
      padding:10px 12px;
      background:rgba(0,0,0,.16);
      cursor:pointer;
      color:white;
      user-select:none;
    }
    .loadingbar{
      height:8px;border-radius:999px;overflow:hidden;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(0,0,0,.14);
      margin-top:10px;
    }
    .loadingbar > div{
      height:100%;width:0%;
      background:rgba(212,175,55,.85);
      transition:width .2s ease;
    }
    .err{color:#fecaca}
  </style>
</head>
<body>
  <div class="wrap" id="app">
  
    <div class="screen" id="splash">
      <div class="card">
        <img
          class="basmalah"
          alt="Basmala calligraphy"
          src="https://upload.wikimedia.org/wikipedia/commons/2/2c/Bismillah.svg"
        />
        <p class="title">Surah Walker</p>
        <p class="small" id="splashLine">Randomly choosing a surah‚Ä¶</p>
        <div class="loadingbar" aria-hidden="true"><div id="bar"></div></div>
        <div class="btn" id="startBtn">Start</div>
        <p class="small" style="margin-top:10px;color:var(--muted2)">
          Tap anywhere to advance word-by-word. üîä = transliteration, üåê = meaning.
        </p>
      </div>
    </div>

    <div class="corner" id="corner" style="display:none">
      <b id="cornerRef">--</b> | <span id="cornerProg">--</span>
    </div>
    <div id="cornerMenu" aria-hidden="true">
      <h4>Surah</h4>
      <div class="row">
        <input type="number" id="surahInput" min="1" max="114" placeholder="1-114" />
        <button class="primary" id="btnLoad">Load</button>
      </div>
      <button id="btnRandom">Random</button>
      <button id="btnReplay" style="margin-top:8px;">Replay current</button>
      <button id="btnCloseMenu" style="margin-top:8px;">Close</button>
    </div>

    <div class="center" id="reader" style="display:none">
      <div class="arabic" id="word">‚Ä¶</div>

      <div class="subrow toggles">
        <div class="pill" id="tglAudio" title="Toggle audio">üó£Ô∏è</div>
        <div class="pill" id="tglPron" title="Toggle pronunciation">üîä</div>
        <div class="pill" id="tglMean" title="Toggle meaning">üåê</div>
      </div> 

      <div class="subrow" style="margin-top:8px">
        <div id="pron" style="display:none"></div>
      </div>
      <div class="subrow" style="margin-top:0">
        <div id="mean" style="display:none"></div>
      </div>

      <!-- Full-verse English translation shown during verse pauses -->
      <div class="subrow" style="margin-top:6px">
        <div id="fullMean" style="display:none;color:var(--muted);max-width:82%;font-size:16px"></div>
      </div>

      <div class="hint" id="hint">Tap/click anywhere to reveal the next word</div>
    </div>
    <footer style="
  position:absolute;
  bottom:10px;
  right:14px;
  font-size:12px;
  color:rgba(255,255,255,.55);
  text-align:right;
  max-width:320px;
  line-height:1.35;
  pointer-events:auto;
">
  <div>
    Surah Walker ‚Äî an open-source, educational Qur‚Äôan reading app.
  </div>
  <div>
    No data collection ¬∑ No ads
  </div>
  <div>
    <a href="https://github.com/comeauchristian-ux/Surah-Walker"
       target="_blank"k
       style="color:rgba(212,175,55,.85);text-decoration:none;">
      Source on GitHub
    </a>
  </div>
</footer>


  </div>

<script>
(() => {
  // Quran.com API (v4) ‚Äúverses by chapter‚Äù endpoint is commonly used like:
  // https://api.quran.com/api/v4/verses/by_chapter/1?language=en&words=true&page=1&per_page=10  (example)
  // We'll fetch per_page=50 and paginate until done.
  const API_BASE = "https://api.quran.com/api/v4";
  const TRANSLATION_ID = 20; // prefer a common English translation (fallbacks will still work)
  const HINT_DELAY_MS = 1250;

  const el = (id) => document.getElementById(id);

  const splash = el("splash");
  const splashLine = el("splashLine");
  const startBtn = el("startBtn");
  const bar = el("bar");

  const corner = el("corner");
  const cornerRef = el("cornerRef");
  const cornerProg = el("cornerProg");
  const cornerMenu = el("cornerMenu");
  const surahInput = el("surahInput");
  const btnLoad = el("btnLoad");
  const btnRandom = el("btnRandom");
  const btnReplay = el("btnReplay");
  const btnCloseMenu = el("btnCloseMenu");

  const reader = el("reader");
  const wordEl = el("word");
  const tglPron = el("tglPron");
  const tglMean = el("tglMean");
  const pronEl = el("pron");
  const meanEl = el("mean");
  const fullMeanEl = el("fullMean");
  const tglAudio = el("tglAudio");
  const hintEl = el("hint");

let audioOn = false;
let voiceAr = null;
let inVersePause = false;
let verseTextByKey = {};
let verseEngByKey = {};
const timeOfDayClasses = ["tod-dawn","tod-day","tod-dusk","tod-night"];
const bgSettings = ["beach","countryside","forest","garden","lakeside","mountain"];
// Derive a stable base so paths work both on GitHub Pages and local dev servers (Live Server)
const pathName = location.pathname.replace(/\\/g, "/");
const baseDir = pathName.endsWith("/")
  ? pathName
  : pathName.replace(/[^/]+$/, "");
const BG_BASE_PATH = `${baseDir.replace(/\/+$/, "/")}assets/bg`;
let chosenSetting = null;
let chosenTimeOfDay = null;

function pickTimeOfDaySlot() {
  const hour = new Date().getHours();
  if (hour >= 4 && hour < 10) return "dawn";
  if (hour >= 10 && hour < 16) return "day";
  if (hour >= 16 && hour < 22) return "dusk";
  return "night";
}

function chooseAndApplyBackgrounds() {
  const body = document.body;
  const tod = pickTimeOfDaySlot();
  chosenTimeOfDay = tod;
  chosenSetting = (tod === "night") ? null : bgSettings[cryptoRandomInt(0, bgSettings.length - 1)];

  timeOfDayClasses.forEach(c => body.classList.remove(c));
  body.classList.add(`tod-${tod}`);

  const makePath = (filename) => `${BG_BASE_PATH}/${filename}`;
  let walkPath = makePath("scenic-pixel-hike.png");
  let pausePath = walkPath;
  if (tod === "night") {
    walkPath = makePath("night_walk.png");
    pausePath = walkPath;
  } else {
    const setting = chosenSetting || bgSettings[0];
    walkPath = makePath(`${setting}_${tod}_walk.png`);
    pausePath = walkPath;
  }

  body.style.setProperty("--bg-img-walk", `url("${walkPath}")`);
  body.style.setProperty("--bg-img-pause", `url("${pausePath}")`);
}

chooseAndApplyBackgrounds();

function pickArabicVoice() {
  const voices = speechSynthesis.getVoices ? speechSynthesis.getVoices() : [];
  // Prefer an Arabic voice if present
  voiceAr =
    voices.find(v => (v.lang || "").toLowerCase().startsWith("ar")) ||
    voices.find(v => /arabic/i.test(v.name || "")) ||
    null;
}

// Some browsers populate voices asynchronously
if ("speechSynthesis" in window) {
  speechSynthesis.onvoiceschanged = () => pickArabicVoice();
  pickArabicVoice();
}

function speakArabic(text) {
  if (!audioOn) return;
  if (!("speechSynthesis" in window)) return;
  if (!text || !text.trim()) return;

  // Cancel any previous word (keeps it crisp)
  speechSynthesis.cancel();


  const u = new SpeechSynthesisUtterance((arabicForTTS(text)));
  u.lang = "ar-SA";
  if (voiceAr) u.voice = voiceAr;

  // Tuning: calm, neutral pace
  u.rate = 0.95;
  u.pitch = 1.0;
  u.volume = 1.0;

  speechSynthesis.speak(u);
}

  // State
  let chapterNumber = null;
  let wordsFlat = []; // [{arabic, translit, meaning, verse_key, wIndexInVerse, wCountInVerse, globalIndex, globalTotal}]
  let idx = 0;
  let showPron = true;
  let showMean = true;
  let started = false;
  let hintTimeoutId = null; // prevents stale hint reveal when tapping quickly
  let menuOpen = false;
  
  function positionMenu(){
    if (!corner || !cornerMenu) return;
    const rect = corner.getBoundingClientRect();
    const top = (rect.bottom || 0) + 8;
    const left = rect.left ? (rect.left + (rect.width || 0)/2) : (window.innerWidth / 2);
    cornerMenu.style.top = `${top}px`;
    cornerMenu.style.left = `${left}px`;
    cornerMenu.style.transform = "translateX(-50%)";
  }

  function closeMenu(){
    menuOpen = false;
    if (cornerMenu) cornerMenu.style.display = "none";
  }

  function openMenu(){
    if (hintTimeoutId !== null) {
      clearTimeout(hintTimeoutId);
      hintTimeoutId = null;
    }
    menuOpen = true;
    if (cornerMenu) cornerMenu.style.display = "block";
    positionMenu();
  }

  function toggleMenu(){
    if (menuOpen) {
      closeMenu();
    } else {
      openMenu();
    }
  }

  function toggleAudio(ev){
  ev.stopPropagation();
  audioOn = !audioOn;
  // Optional: visually indicate state
  tglAudio.style.background = audioOn ? "rgba(212,175,55,.20)" : "rgba(0,0,0,.12)";
  tglAudio.style.borderColor = audioOn ? "rgba(212,175,55,.55)" : "rgba(255,255,255,.18)";
}

  function cryptoRandomInt(minInclusive, maxInclusive){
    const span = maxInclusive - minInclusive + 1;
    const buf = new Uint32Array(1);
    crypto.getRandomValues(buf);
    return minInclusive + (buf[0] % span);
  }

  async function fetchAllVersesByChapter(chNum){
    const perPage = 50;
    let page = 1;
    let all = [];
    while(true){
const url = `${API_BASE}/verses/by_chapter/${chNum}?language=en&translations=${TRANSLATION_ID}&words=true&word_fields=text_uthmani,translation,transliteration&page=${page}&per_page=${perPage}`;
      const res = await fetch(url, { headers: { "Accept": "application/json" }});
      if(!res.ok){
        throw new Error(`API error ${res.status} on page ${page}`);
      }
      const data = await res.json();
      if(!data || !data.verses) throw new Error("Unexpected API response.");
      all = all.concat(data.verses);

      // Progress bar (rough, based on pages)
      const totalPages = (data.pagination && data.pagination.total_pages) ? Number(data.pagination.total_pages) : null;
      if(totalPages){
        bar.style.width = `${Math.min(100, Math.round((page/totalPages)*100))}%`;
      } else {
        bar.style.width = `${Math.min(95, page*10)}%`;
      }

      const nextPage = data.pagination && data.pagination.next_page ? Number(data.pagination.next_page) : null;
      if(!nextPage) break;
      page = nextPage;
    }
    bar.style.width = "100%";
    return all;
  }
function getVerseKey(w) {
  return w?.verse_key || w?.verseKey || w?.verse || "";
}
  function flattenWords(verses){
    const out = [];
    for(const v of verses){
      const verseKey = v.verse_key || `${v.chapter_id}:${v.verse_number}`;
      const words = Array.isArray(v.words) ? v.words : [];
      const count = words.length;
      let wIndex = 0;
      for(const w of words){
        if(w.char_type_name && w.char_type_name !== "word") continue; // skip pause marks etc.
        wIndex += 1;
        out.push({
          arabic: w.text_uthmani || "",
          translit: (w.transliteration && w.transliteration.text) ? w.transliteration.text : "",
          meaning: (w.translation && w.translation.text) ? w.translation.text : "",
          verse_key: verseKey,
          wIndexInVerse: wIndex,
          wCountInVerse: count
        });
      }
    }
    // Add global counters
    const total = out.length;
    out.forEach((x,i) => {
      x.globalIndex = i+1;
      x.globalTotal = total;
    });
    return out;
  }

  function render(){
    if (hintTimeoutId !== null) {
      clearTimeout(hintTimeoutId); // cancel prior delayed hint update (stale guard)
      hintTimeoutId = null;
    }
    const cur = wordsFlat[idx];
    if(!cur){
      wordEl.textContent = "‚úì";
      pronEl.textContent = "";
      meanEl.textContent = "";
      cornerRef.textContent = `${chapterNumber}:end`;
      cornerProg.textContent = `done`;
      return;
    }
  if (inVersePause) {
    document.body.classList.add("resting");
    const k = getVerseKey(cur);

    // Show Arabic verse (smaller); hide English translation during pause
    wordEl.style.display = "block";
    wordEl.textContent = verseTextByKey[k] || cur.arabic || "‚Ä¶";
    wordEl.style.fontSize = "34px";
    wordEl.style.lineHeight = "1.4";

    fullMeanEl.style.display = "none";
    fullMeanEl.textContent = "";

    // Also show a subtle English hint in the hint area (more transparent)
    if (hintEl) {
      // Hide the bottom hint so we don't repeat the translation
      hintEl.style.display = "none";
    }

    // Hide per-word aids and toggle buttons during the verse pause (including audio)
    pronEl.style.display = "none";
    meanEl.style.display = "none";
    pronEl.textContent = "";
    meanEl.textContent = "";
    pronEl.style.opacity = 0;
    meanEl.style.opacity = 0;
    tglPron.style.display = "none";
    tglMean.style.display = "none";
    tglAudio.style.display = "none";

    // Center the corner reference horizontally while paused
    corner.style.left = "50%";
    corner.style.transform = "translateX(-50%)";
    corner.style.top = "calc(12px + env(safe-area-inset-top, 0px))";

    return;
  }

  // Normal word mode
 
   document.body.classList.remove("resting");
   // Restore normal display
   wordEl.style.display = "block";
   fullMeanEl.style.display = "none";

   wordEl.textContent = cur.arabic || "‚Ä¶";
   wordEl.style.fontSize = "56px";
   wordEl.style.lineHeight = "1.25";
    cornerRef.textContent = cur.verse_key;
    cornerProg.textContent = `${cur.globalIndex}/${cur.globalTotal}`;

   // Restore toggle buttons and per-word aids (allow CSS to control display)
   tglPron.style.display = "";
   tglMean.style.display = "";

   // Restore audio toggle
   tglAudio.style.display = "";

   // Restore hint text
   if (hintEl) {
     hintEl.textContent = "Tap/click anywhere to reveal the next word";
     hintEl.style.color = '';
     hintEl.style.display = "";
   }

  // Per-word assistant texts (delayed fade-in to reduce visual competition)
  pronEl.style.display = showPron ? "block" : "none";
  meanEl.style.display = showMean ? "block" : "none";
  pronEl.textContent = "";
  meanEl.textContent = "";
  pronEl.style.opacity = 0;
  meanEl.style.opacity = 0;
  hintTimeoutId = setTimeout(() => {
    // Delayed hint reveal; stale timers are cleared at render start
    if (showPron) {
      pronEl.style.display = "block";
      pronEl.textContent = cur.translit || "";
      requestAnimationFrame(() => { pronEl.style.opacity = 1; });
    } else {
      pronEl.style.display = "none";
      pronEl.textContent = "";
      pronEl.style.opacity = 0;
    }
    if (showMean) {
      meanEl.style.display = "block";
      meanEl.textContent = cur.meaning || getApproxMeaning(cur) || "";
      requestAnimationFrame(() => { meanEl.style.opacity = 1; });
    } else {
      meanEl.style.display = "none";
      meanEl.textContent = "";
      meanEl.style.opacity = 0;
    }
    console.debug('render normal', { idx, showPron, pronText: pronEl.textContent, showMean, meanText: meanEl.textContent, fallbackUsed: !!(showMean && !cur.meaning) });
  }, HINT_DELAY_MS);

   // Restore corner position
   corner.style.left = "50%";
   corner.style.transform = "translateX(-50%)";
   corner.style.top = "calc(12px + env(safe-area-inset-top, 0px))";
  }

  function nextWord(){
    if(!started) return;
    if(menuOpen) return;
    if (splash && splash.style.display !== "none") return;

    const cur = wordsFlat[idx];
    if (!cur) return;

    // If we're currently resting on the verse, next tap moves on
    if (inVersePause) {
      inVersePause = false;
      render();
      // Now actually advance to the next word (first of next verse)
      idx = Math.min(idx + 1, wordsFlat.length);
      render();
      const now = wordsFlat[idx];
      if (now) speakArabic(now.arabic);
      return;
    }

    // Look ahead: if next word is in a different verse (or doesn't exist), we pause
    const next = wordsFlat[idx + 1];
    const isEndOfVerse = (!next) || (next.verse_key !== cur.verse_key);

    if (isEndOfVerse) {
      inVersePause = true;
      render();          // show the full verse
      return;            // do NOT advance yet
    }

    // Normal advance within verse
    idx += 1;
    render();
    const now = wordsFlat[idx];
    if (now) speakArabic(now.arabic);
  }

  function togglePron(ev){
    ev.stopPropagation();
    showPron = !showPron;
    console.debug('togglePron ->', showPron, 'idx=', idx, 'translit=', (wordsFlat[idx] && wordsFlat[idx].translit));
    render();
  }
  function toggleMean(ev){
    ev.stopPropagation();
    showMean = !showMean;
    console.debug('toggleMean ->', showMean, 'idx=', idx, 'meaning=', (wordsFlat[idx] && wordsFlat[idx].meaning));
    render();
  }

  async function init(){
    chapterNumber = cryptoRandomInt(1,114);
    splashLine.textContent = `Random surah selected: ${chapterNumber}. FetchingÔøΩ`;
    await loadSurah(chapterNumber, { autoStart: false });
  }

  function arabicForTTS(text) {
  return String(text || "")
    // Remove tatweel
    .replace(/\u0640/g, "")

    // Remove Qur'anic annotation marks (stops, small signs, etc.)
    .replace(/[\u06D6-\u06ED]/g, "")
    .replace(/[€ù€û€©]/g, "")

    // Normalize whitespace
    .replace(/\s+/g, " ")
    .trim();
}

// Strip any HTML/footnote content starting at the first '<' and normalize whitespace
function sanitizeEnglish(s) {
  return String(s || "").replace(/<([\s\S]*)$/g, "").replace(/\s+/g, " ").trim();
}

// Approximate a per-word English meaning by mapping word position in the verse
function getApproxMeaning(cur) {
  try {
    const k = cur && cur.verse_key;
    const verse = (k && verseEngByKey[k]) ? String(verseEngByKey[k]) : "";
    if (!verse) return "";
    const engWords = verse.split(/\s+/).filter(Boolean);
    if (engWords.length === 0) return "";
    const wIndex = Number(cur.wIndexInVerse || 1);
    const wCount = Number(cur.wCountInVerse || 1);
    // Map position proportionally
    const pos = wCount > 1 ? (wIndex - 1) / (wCount - 1) : 0;
    const idx = Math.max(0, Math.min(engWords.length - 1, Math.round(pos * (engWords.length - 1))));
    // Return a small window for context
    const start = Math.max(0, idx - 1);
    const end = Math.min(engWords.length, idx + 2);
    return sanitizeEnglish(engWords.slice(start, end).join(" "));
  } catch (e) {
    return "";
  }
}
  async function loadSurah(chNum, { autoStart = true } = {}) {
    try { if (window.speechSynthesis && speechSynthesis.cancel) speechSynthesis.cancel(); } catch(e) {}
    if (hintTimeoutId !== null) {
      clearTimeout(hintTimeoutId);
      hintTimeoutId = null;
    }
    closeMenu();
    menuOpen = false;
    idx = 0;
    inVersePause = false;
    const target = Math.min(114, Math.max(1, Number(chNum) || 1));
    chapterNumber = target;
    started = !!autoStart;
    splash.style.display = "block";
    splashLine.textContent = `Loading surah ${chapterNumber}ÔøΩ`;
    bar.style.width = "0%";
    reader.style.display = "none";
    corner.style.display = "none";

    let verses;
    try {
      verses = await fetchAllVersesByChapter(chapterNumber);
    } catch(e) {
      splashLine.innerHTML = `<span class="err">Couldn't load the surah (${String(e.message || e)}).</span>`;
      startBtn.textContent = "Retry";
      startBtn.onclick = async (ev) => { ev.stopPropagation(); bar.style.width = "0%"; splashLine.textContent = "RetryingÔøΩ"; await loadSurah(chapterNumber, { autoStart: false }); };
      return;
    }

    const verseTextParts = {};
    const verseEngParts = {};

    for (const v of verses) {
      const k = v.verse_key || `${v.chapter_id}:${v.verse_number}`;
      const words = Array.isArray(v.words) ? v.words.map(w => w.text_uthmani || "").filter(Boolean) : [];
      if (words.length) verseTextParts[k] = (verseTextParts[k] ?? []).concat(words);

      let eng = "";
      if (v.translations && v.translations.length) {
        eng = v.translations.map(t => t.text || "").join(" ");
      } else if (v.translation && v.translation.text) {
        eng = v.translation.text;
      } else if (v.translated_text) {
        eng = v.translated_text;
      }
      if (eng) verseEngParts[k] = (verseEngParts[k] ?? []).concat(sanitizeEnglish(eng));
    }

    wordsFlat = flattenWords(verses);

    for (const w of wordsFlat) {
      const k = getVerseKey(w);
      if (!k) continue;
      const hasVerseText = Array.isArray(verseTextParts[k]) && verseTextParts[k].length > 0;
      if (!hasVerseText) {
        verseTextParts[k] = (verseTextParts[k] ?? []).concat(w.arabic);
      }
      if (!verseEngParts[k]) verseEngParts[k] = [];
      if (!verseEngParts[k].length) verseEngParts[k].push(sanitizeEnglish(w.meaning));
    }

    verseTextByKey = {};
    verseEngByKey = {};
    for (const k in verseTextParts) {
      verseTextByKey[k] = Array.isArray(verseTextParts[k]) ? verseTextParts[k].join(" ") : String(verseTextParts[k] || "");
    }
    for (const k in verseEngParts) {
      verseEngByKey[k] = sanitizeEnglish(Array.isArray(verseEngParts[k]) ? verseEngParts[k].join(" ").replace(/\s+/g, " ").trim() : String(verseEngParts[k] || ""));
    }

    if (!autoStart) {
      started = false;
      splashLine.textContent = `Ready. Surah ${chapterNumber} ÔøΩ ${wordsFlat.length} words`;
      startBtn.textContent = "Start";
      return;
    }

    splash.style.display = "none";
    corner.style.display = "block";
    reader.style.display = "block";
    idx = 0;
    render();
    const cur = wordsFlat[idx];
    if (cur) speakArabic(cur.arabic);
  }
  async function start() {
    closeMenu();
    menuOpen = false;
    if (!wordsFlat || !wordsFlat.length) {
      const fallback = chapterNumber || cryptoRandomInt(1,114);
      await loadSurah(fallback, { autoStart: true });
      return;
    }
    started = true;
    splash.style.display = "none";
    corner.style.display = "block";
    reader.style.display = "block";
    idx = 0;
    showPron = true;
    showMean = true;
    render();
	const cur = wordsFlat[idx];
if (cur) speakArabic(cur.arabic);
  }

  // Events
  // Use a single pointer handler to avoid mobile double-fire (touchstart+click)
  function handlePointerDown(ev){
    if (menuOpen) {
      if (cornerMenu && !cornerMenu.contains(ev.target) && ev.target !== corner) {
        closeMenu();
      }
      return;
    }
    nextWord();
  }
  document.addEventListener("pointerdown", handlePointerDown);

  // Prevent pointer events on controls from bubbling to the document
  const stopAnd = (fn) => (ev) => { ev.stopPropagation(); fn(ev); };
  tglPron.addEventListener("pointerdown", stopAnd(togglePron));
  tglMean.addEventListener("pointerdown", stopAnd(toggleMean));
  tglAudio.addEventListener("pointerdown", stopAnd(toggleAudio));
  startBtn.addEventListener("pointerdown", (ev) => { ev.stopPropagation(); start(); });

  if (corner) corner.addEventListener("pointerdown", (ev) => { ev.stopPropagation(); toggleMenu(); positionMenu(); });
  if (cornerMenu) cornerMenu.addEventListener("pointerdown", (ev) => ev.stopPropagation());
  if (btnCloseMenu) btnCloseMenu.addEventListener("pointerdown", (ev) => { ev.stopPropagation(); closeMenu(); });
  if (btnRandom) btnRandom.addEventListener("pointerdown", async (ev) => { ev.stopPropagation(); await loadSurah(cryptoRandomInt(1,114), { autoStart: true }); });
  if (btnReplay) btnReplay.addEventListener("pointerdown", async (ev) => { ev.stopPropagation(); await loadSurah(chapterNumber || 1, { autoStart: true }); });
  if (btnLoad) btnLoad.addEventListener("pointerdown", async (ev) => {
    ev.stopPropagation();
    const val = Number(surahInput && surahInput.value ? surahInput.value : chapterNumber || 1);
    const target = Math.min(114, Math.max(1, val || 1));
    await loadSurah(target, { autoStart: true });
  });
  if (surahInput) surahInput.addEventListener("pointerdown", (ev) => ev.stopPropagation());
  document.addEventListener("keydown", (ev) => {
    if (ev.key === "Escape" && menuOpen) {
      closeMenu();
    }
  });
  window.addEventListener("resize", () => { if (menuOpen) positionMenu(); });

  // Boot
  (async () => {
    try{
      await init();
    } catch(e){
      splashLine.innerHTML = `<span class="err">Couldn‚Äôt load the surah (${String(e.message || e)}).</span><br><span class="small">You need an internet connection, and the API must allow your browser (CORS).</span>`;
      startBtn.textContent = "Retry";
      startBtn.onclick = async (ev) => {
        ev.stopPropagation();
        bar.style.width = "0%";
        splashLine.textContent = "Retrying‚Ä¶";
        try{ await init(); } catch(err){ splashLine.textContent = String(err.message || err); }
      };
      return;
    }
  })();
})();
</script>
</body>
</html>






























