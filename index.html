<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Surah Walker</title>
  <style>
    :root{
      --bg:#064e3b;        /* dark emerald */
      --gold:#ffd54a;      /* gold */
      --muted:#cbd5e1;     /* slate-ish */
      --muted2:#94a3b8;
    }
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    body{
      --bg-img-walk: url("assets/bg/beach_day_walk.png");
      --bg-img-pause: var(--bg-img-walk);
      background: var(--bg-img-walk);
      background-size: cover;
      background-position: center center;
      background-repeat: no-repeat;
      background-attachment: fixed;
      color:white;display:flex;align-items:center;justify-content:center;
      position:relative;
      overflow:hidden;
    }
    /* Slightly blur the background without affecting foreground text */
    body::after{
      content:"";
      position:fixed;
      inset:-2%;
      background: var(--bg-img-walk);
      background-size: cover;
      background-position: center center;
      background-repeat: no-repeat;
      background-attachment: fixed;
      filter: blur(1px);
      transform: scale(1.03);
      z-index:0;
      pointer-events:none;
    }

    /* Time-of-day hooks (only swap images; no overlays) */
    body.tod-dawn{}
    body.tod-day{}
    body.tod-dusk{}
    body.tod-night{}

	body.resting {
      background: var(--bg-img-pause);
      background-size: cover;
      background-position: center center;
      background-repeat: no-repeat;
      background-attachment: fixed;
}

    .wrap{
      width:min(1100px, 92vw);
      height:100vh;
      position:relative;
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:1; /* keep content above blurred background layer */
    }
    .corner{
      position:absolute;top:14px;left:14px;
      font-size:14px;color:var(--muted);
      letter-spacing:.2px;
      user-select:none;
    }
    .corner b{color:white;font-weight:650}
    .center{
      position:relative; /* allow content to center within .wrap */
      display:flex;flex-direction:column;align-items:center;justify-content:center;
      text-align:center;gap:18px;
      user-select:none;
      max-width:86vw;
      padding:48px 1px;
      padding-bottom:160px; /* leave room for bottom controls while lowering text into the plate */
    }
    /* Reading plate to keep text legible */
    .center::before{
      content:"";
      position:absolute;
      inset:0% 0% 0% 0%; /* trim the bottom so the plate doesn‚Äôt run to the edge */
      border-radius:28px;
      background:rgba(21, 69, 57, 0.404);
      border:1px solid rgba(255,255,255,0.12);
      backdrop-filter:blur(4px);
      pointer-events:none;
      z-index:0;
    }
    .center > *{
      position:relative;
      z-index:1;
    }

    @media (min-width:1000px){
      .center{
        padding-top:72px;
        padding-bottom:200px;
      }
    }
    .arabic{
      font-size:56px;line-height:1.25;
      color:var(--gold);
      padding:0 10px;
      direction:rtl;
      font-family: "Amiri", "Scheherazade New", "Noto Naskh Arabic", serif;
      text-align:center;
      max-width:92vw;
      word-break:keep-all;
      /* reverted to simpler gold color for clarity */
      text-shadow: 0 6px 18px rgba(0,0,0,0.22);
      font-weight:600;
    }
    .subrow{
      margin-top:18px;
      display:flex;gap:14px;align-items:center;justify-content:center;
      color:var(--muted);
      font-size:16px;
      min-height:28px;
    }
    .pill{
      border:1px solid rgba(255,255,255,.18);
      border-radius:999px;
      padding:8px 14px;
      background:rgba(0,0,0,.12);
      cursor:pointer;
      user-select:none;
      font-size:16px;
      min-width:48px;
      height:48px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
    }
    .hint{
      position:fixed;bottom:120px;left:50%;transform:translateX(-50%);
      color:rgba(255,255,255,0.60);font-size:14px;z-index:9999;
      user-select:none;text-align:center;max-width:72%;line-height:1.4;opacity:0.95;
    }
    /* bottom-centered toggles pinned to viewport (avoid overlapping center content) */
    .subrow.toggles{ position:fixed; bottom:34px; left:50%; transform:translateX(-50%); gap:18px; z-index:10000; }

    #fullMean{ color:rgba(203,213,225,0.86); max-width:82%; font-size:16px; margin:12px auto 0; text-align:center; padding:0 18px; opacity:0.92; transition:opacity .18s ease, transform .18s ease; }
    #pron, #mean{ font-size:16px; color:rgba(203,213,225,0.78); margin-top:18px; opacity:0.9; transition:opacity .18s ease, transform .18s ease; position:relative; z-index:2000; }

    
    /* make assistant texts subtler on large screens */
    @media (min-width:1000px){
      #fullMean{ font-size:22px; opacity:0.88; }
      #pron, #mean{ font-size:20px; opacity:0.8; }
    }

    @media (min-width:1000px){
      .arabic{ font-size:120px; line-height:1.02; }
      #fullMean{ font-size:26px; max-width:72%; }
      #pron, #mean{ font-size:20px; }
      .pill{ padding:12px 18px; font-size:18px; min-width:60px; height:56px; }
      .wrap{ height:100vh; }
    }
    @media (min-width:1400px){
      .arabic{ font-size:160px; }
      #fullMean{ font-size:30px; }
    }

    .screen{
      position:absolute;inset:0;
      display:flex;flex-direction:column;align-items:center;justify-content:center;
      gap:18px;
    }
    #library{
      align-items:center;
      justify-content:center;
      padding:12px;
    }
    .libraryStage{
      position:relative;
      width:min(1200px, 96vw);
      max-width:100%;
    }
    .libraryBg{
      width:100%;
      height:auto;
      display:block;
      border-radius:18px;
      box-shadow:0 12px 36px rgba(0,0,0,0.28);
    }
    .hotspot{
      position:absolute;
      border:0;
      padding:0;
      margin:0;
      background:transparent;
      cursor:pointer;
    }
    .hotspotLabel{
      display:none;
      font-size:12px;
      color:white;
      background:rgba(0,0,0,0.6);
      padding:3px 6px;
      border-radius:6px;
      pointer-events:none;
      position:absolute;
      top:4px;left:4px;
    }
    body.debug-hotspots .hotspot{
      outline:2px dashed rgba(255,255,255,0.8);
      background:rgba(255,215,74,0.18);
    }
    body.debug-hotspots .hotspotLabel{ display:block; }
    .card{
      width:min(520px, 86vw);
      background:rgba(0,0,0,.14);
      border:1px solid rgba(255,255,255,.18);
      border-radius:20px;
      padding:18px 16px;
    }
    .title{
      font-size:20px;font-weight:700;letter-spacing:.2px;
      margin:0 0 6px 0;
    }
    .small{color:var(--muted);font-size:14px;margin:0}
    img.basmalah{
      max-width:280px;width:60%;
      height:auto;display:block;margin:0 auto 10px auto;
      filter: drop-shadow(0 8px 18px rgba(0,0,0,.25));
      border-radius:12px;
      background:rgba(255,255,255,.06);
      padding:10px;
    }
    .btn{
      display:inline-block;
      margin-top:10px;
      border:1px solid rgba(255,255,255,.22);
      border-radius:14px;
      padding:10px 12px;
      background:rgba(0,0,0,.16);
      cursor:pointer;
      color:white;
      user-select:none;
    }
    .loadingbar{
      height:8px;border-radius:999px;overflow:hidden;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(0,0,0,.14);
      margin-top:10px;
    }
    .loadingbar > div{
      height:100%;width:0%;
      background:rgba(212,175,55,.85);
      transition:width .2s ease;
    }
    .err{color:#fecaca}
  </style>
</head>
<body>
  <div class="wrap" id="app">
  
    <div class="screen" id="library">
      <div class="libraryStage" id="libraryStage">
        <img
          class="libraryBg"
          src="assets/ui/library-1920.png"
          alt="Library bookshelf"
        />
      </div>
    </div>
  
    <div class="screen" id="splash">
      <div class="card">
        <img
          class="basmalah"
          alt="Basmala calligraphy"
          src="https://upload.wikimedia.org/wikipedia/commons/2/2c/Bismillah.svg"
        />
        <p class="title">Surah Walker</p>
        <p class="small" id="splashLine">Randomly choosing a surah‚Ä¶</p>
        <div class="loadingbar" aria-hidden="true"><div id="bar"></div></div>
        <div class="btn" id="startBtn">Start</div>
        <p class="small" style="margin-top:10px;color:var(--muted2)">
          Tap anywhere to advance word-by-word. üîä = transliteration, üåê = meaning.
        </p>
      </div>
    </div>

    <div class="corner" id="corner" style="display:none">
      <b id="cornerRef">‚Äì</b> ¬∑ <span id="cornerProg">‚Äì</span>
    </div>

    <div class="center" id="reader" style="display:none">
      <div class="arabic" id="word">‚Ä¶</div>

      <div class="subrow toggles">
        <div class="pill" id="tglAudio" title="Toggle audio">üó£Ô∏è</div>
        <div class="pill" id="tglPron" title="Toggle pronunciation">üîä</div>
        <div class="pill" id="tglMean" title="Toggle meaning">üåê</div>
      </div> 

      <div class="subrow" style="margin-top:8px">
        <div id="pron" style="display:none"></div>
      </div>
      <div class="subrow" style="margin-top:0">
        <div id="mean" style="display:none"></div>
      </div>

      <!-- Full-verse English translation shown during verse pauses -->
      <div class="subrow" style="margin-top:6px">
        <div id="fullMean" style="display:none;color:var(--muted);max-width:82%;font-size:16px"></div>
      </div>

      <div class="hint" id="hint">Tap/click anywhere to reveal the next word</div>
    </div>
  </div>

<script>
(() => {
  // Quran.com API (v4) ‚Äúverses by chapter‚Äù endpoint is commonly used like:
  // https://api.quran.com/api/v4/verses/by_chapter/1?language=en&words=true&page=1&per_page=10  (example)
  // We'll fetch per_page=50 and paginate until done.
  const API_BASE = "https://api.quran.com/api/v4";
  const TRANSLATION_ID = 20; // prefer a common English translation (fallbacks will still work)

  const el = (id) => document.getElementById(id);

  const splash = el("splash");
  const splashLine = el("splashLine");
  const startBtn = el("startBtn");
  const bar = el("bar");

  const corner = el("corner");
  const cornerRef = el("cornerRef");
  const cornerProg = el("cornerProg");

  const reader = el("reader");
  const wordEl = el("word");
  const tglPron = el("tglPron");
  const tglMean = el("tglMean");
  const pronEl = el("pron");
  const meanEl = el("mean");
  const fullMeanEl = el("fullMean");
  const tglAudio = el("tglAudio");
  const hintEl = el("hint");
  const libraryStage = el("libraryStage");
  const libraryScreen = el("library");

  const screens = ["library", "splash", "reader"];
  const STORAGE_KEYS = {
    lastSurah: "surahWalker:lastSurah",
    lastWordIndex: "surahWalker:lastWordIndex",
    toggles: "surahWalker:readerToggles"
  };

let audioOn = false;
let voiceAr = null;
let inVersePause = false;
let verseTextByKey = {};
let verseEngByKey = {};
const timeOfDayClasses = ["tod-dawn","tod-day","tod-dusk","tod-night"];
const bgSettings = ["beach","countryside","forest","garden","lakeside","mountain"];
// Derive a stable base so paths work both on GitHub Pages and local dev servers (Live Server)
const pathName = location.pathname.replace(/\\/g, "/");
const baseDir = pathName.endsWith("/")
  ? pathName
  : pathName.replace(/[^/]+$/, "");
const BG_BASE_PATH = `${baseDir.replace(/\/+$/, "/")}assets/bg`;
let chosenSetting = null;
let chosenTimeOfDay = null;

function showScreen(name) {
  screens.forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    el.style.display = (id === name) ? "flex" : "none";
  });
  corner.style.display = name === "reader" ? "block" : "none";
}

function pickTimeOfDaySlot() {
  const hour = new Date().getHours();
  if (hour >= 4 && hour < 10) return "dawn";
  if (hour >= 10 && hour < 16) return "day";
  if (hour >= 16 && hour < 22) return "dusk";
  return "night";
}

function chooseAndApplyBackgrounds() {
  const body = document.body;
  const tod = pickTimeOfDaySlot();
  chosenTimeOfDay = tod;
  chosenSetting = (tod === "night") ? null : bgSettings[cryptoRandomInt(0, bgSettings.length - 1)];

  timeOfDayClasses.forEach(c => body.classList.remove(c));
  body.classList.add(`tod-${tod}`);

  const makePath = (filename) => `${BG_BASE_PATH}/${filename}`;
  let walkPath = makePath("scenic-pixel-hike.png");
  let pausePath = walkPath;
  if (tod === "night") {
    walkPath = makePath("night_walk.png");
    pausePath = walkPath;
  } else {
    const setting = chosenSetting || bgSettings[0];
    walkPath = makePath(`${setting}_${tod}_walk.png`);
    pausePath = walkPath;
  }

  body.style.setProperty("--bg-img-walk", `url("${walkPath}")`);
  body.style.setProperty("--bg-img-pause", `url("${pausePath}")`);
}

loadStoredPreferences();
chooseAndApplyBackgrounds();

const hotspotDefs = [
  { id: "random", action: "random", left: 11, top: 10, width: 9, height: 46, label: "Random" },
  { id: "range-1", action: "range", left: 20, top: 14, width: 5.5, height: 40, label: "1", min: 1, max: 9 },
  { id: "range-10", action: "range", left: 25.5, top: 14, width: 6, height: 40, label: "10", min: 10, max: 19 },
  { id: "range-20", action: "range", left: 31.5, top: 14, width: 6, height: 40, label: "20", min: 20, max: 29 },
  { id: "range-30", action: "range", left: 38, top: 14, width: 6, height: 40, label: "30", min: 30, max: 39 },
  { id: "range-40", action: "range", left: 44.5, top: 14, width: 5.5, height: 40, label: "40", min: 40, max: 49 },
  { id: "range-50", action: "range", left: 50.5, top: 14, width: 5.5, height: 40, label: "50", min: 50, max: 59 },
  { id: "range-60", action: "range", left: 56, top: 14, width: 7, height: 40, label: "60", min: 60, max: 69 },
  { id: "range-70", action: "range", left: 63, top: 14, width: 8, height: 40, label: "70", min: 70, max: 79 },
  { id: "favorites", action: "favorites", left: 71, top: 13, width: 9, height: 42, label: "Favorites" },
  { id: "continue", action: "continue", left: 13, top: 70, width: 38, height: 20, label: "Continue" },
  { id: "journal", action: "journal", left: 46, top: 55, width: 26, height: 15, label: "Journal" },
  { id: "settings", action: "settings", left: 73, top: 55, width: 26, height: 30, label: "Settings" }
];

function buildLibraryHotspots(){
  if(!libraryStage) return;
  hotspotDefs.forEach(h => {
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "hotspot";
    btn.dataset.action = h.action;
    btn.dataset.id = h.id;
    if(h.min !== undefined) btn.dataset.min = String(h.min);
    if(h.max !== undefined) btn.dataset.max = String(h.max);
    btn.style.left = `${h.left}%`;
    btn.style.top = `${h.top}%`;
    btn.style.width = `${h.width}%`;
    btn.style.height = `${h.height}%`;
    const label = document.createElement("span");
    label.className = "hotspotLabel";
    label.textContent = h.label || h.id;
    btn.appendChild(label);
    libraryStage.appendChild(btn);
  });
}

buildLibraryHotspots();

function handleLibraryClick(ev){
  const target = ev.target.closest(".hotspot");
  if(!target) return;
  ev.preventDefault();
  ev.stopPropagation();
  const action = target.dataset.action;
  switch(action){
    case "random":
      startRandom();
      break;
    case "continue":
      startContinue();
      break;
    case "range": {
      const min = Number(target.dataset.min);
      const max = Number(target.dataset.max);
      startRange(min, max);
      break;
    }
    case "favorites":
      openFavorites();
      break;
    case "journal":
      openJournal();
      break;
    case "settings":
      openSettings();
      break;
    default:
      break;
  }
}

if(libraryStage){
  libraryStage.addEventListener("pointerdown", handleLibraryClick);
}

function pickArabicVoice() {
  const voices = speechSynthesis.getVoices ? speechSynthesis.getVoices() : [];
  // Prefer an Arabic voice if present
  voiceAr =
    voices.find(v => (v.lang || "").toLowerCase().startsWith("ar")) ||
    voices.find(v => /arabic/i.test(v.name || "")) ||
    null;
}

// Some browsers populate voices asynchronously
if ("speechSynthesis" in window) {
  speechSynthesis.onvoiceschanged = () => pickArabicVoice();
  pickArabicVoice();
}

function speakArabic(text) {
  if (!audioOn) return;
  if (!("speechSynthesis" in window)) return;
  if (!text || !text.trim()) return;

  // Cancel any previous word (keeps it crisp)
  speechSynthesis.cancel();


  const u = new SpeechSynthesisUtterance((arabicForTTS(text)));
  u.lang = "ar-SA";
  if (voiceAr) u.voice = voiceAr;

  // Tuning: calm, neutral pace
  u.rate = 0.95;
  u.pitch = 1.0;
  u.volume = 1.0;

  speechSynthesis.speak(u);
}

  // State
  let chapterNumber = null;
  let wordsFlat = []; // [{arabic, translit, meaning, verse_key, wIndexInVerse, wCountInVerse, globalIndex, globalTotal}]
  let idx = 0;
  let showPron = true;
  let showMean = true;
  let started = false;
  let savedSurahNumber = null;
  let savedWordIndex = 0;

  const clampIndex = (i) => {
    if (!wordsFlat.length) return 0;
    return Math.max(0, Math.min(wordsFlat.length - 1, i));
  };

  function loadStoredPreferences(){
    try{
      const rawToggles = localStorage.getItem(STORAGE_KEYS.toggles);
      if(rawToggles){
        const toggles = JSON.parse(rawToggles);
        if(typeof toggles.showPron === "boolean") showPron = toggles.showPron;
        if(typeof toggles.showMean === "boolean") showMean = toggles.showMean;
        if(typeof toggles.audioOn === "boolean") audioOn = toggles.audioOn;
      }
      const savedSurah = Number(localStorage.getItem(STORAGE_KEYS.lastSurah));
      if(Number.isFinite(savedSurah)) savedSurahNumber = savedSurah;
      const savedIdx = Number(localStorage.getItem(STORAGE_KEYS.lastWordIndex));
      if(Number.isFinite(savedIdx)) savedWordIndex = savedIdx;
    } catch(e){
      // Ignore storage errors (private mode, etc.)
    }
  }

  function saveProgress(){
    if(chapterNumber === null || chapterNumber === undefined) return;
    try{
      localStorage.setItem(STORAGE_KEYS.lastSurah, String(chapterNumber));
      localStorage.setItem(STORAGE_KEYS.lastWordIndex, String(idx || 0));
      localStorage.setItem(STORAGE_KEYS.toggles, JSON.stringify({ showPron, showMean, audioOn }));
      savedSurahNumber = chapterNumber;
      savedWordIndex = idx || 0;
    } catch(e){
      // Ignore storage errors
    }
  }
  
  function toggleAudio(ev){
  ev.stopPropagation();
  audioOn = !audioOn;
  // Optional: visually indicate state
  syncAudioToggleVisual();
  saveProgress();
}
  function syncAudioToggleVisual(){
    tglAudio.style.background = audioOn ? "rgba(212,175,55,.20)" : "rgba(0,0,0,.12)";
    tglAudio.style.borderColor = audioOn ? "rgba(212,175,55,.55)" : "rgba(255,255,255,.18)";
  }

  function cryptoRandomInt(minInclusive, maxInclusive){
    const span = maxInclusive - minInclusive + 1;
    const buf = new Uint32Array(1);
    crypto.getRandomValues(buf);
    return minInclusive + (buf[0] % span);
  }

  async function fetchAllVersesByChapter(chNum){
    const perPage = 50;
    let page = 1;
    let all = [];
    while(true){
const url = `${API_BASE}/verses/by_chapter/${chNum}?language=en&translations=${TRANSLATION_ID}&words=true&word_fields=text_uthmani,translation,transliteration&page=${page}&per_page=${perPage}`;
      const res = await fetch(url, { headers: { "Accept": "application/json" }});
      if(!res.ok){
        throw new Error(`API error ${res.status} on page ${page}`);
      }
      const data = await res.json();
      if(!data || !data.verses) throw new Error("Unexpected API response.");
      all = all.concat(data.verses);

      // Progress bar (rough, based on pages)
      const totalPages = (data.pagination && data.pagination.total_pages) ? Number(data.pagination.total_pages) : null;
      if(totalPages){
        bar.style.width = `${Math.min(100, Math.round((page/totalPages)*100))}%`;
      } else {
        bar.style.width = `${Math.min(95, page*10)}%`;
      }

      const nextPage = data.pagination && data.pagination.next_page ? Number(data.pagination.next_page) : null;
      if(!nextPage) break;
      page = nextPage;
    }
    bar.style.width = "100%";
    return all;
  }
function getVerseKey(w) {
  return w?.verse_key || w?.verseKey || w?.verse || "";
}
  function flattenWords(verses){
    const out = [];
    for(const v of verses){
      const verseKey = v.verse_key || `${v.chapter_id}:${v.verse_number}`;
      const words = Array.isArray(v.words) ? v.words : [];
      const count = words.length;
      let wIndex = 0;
      for(const w of words){
        if(w.char_type_name && w.char_type_name !== "word") continue; // skip pause marks etc.
        wIndex += 1;
        out.push({
          arabic: w.text_uthmani || "",
          translit: (w.transliteration && w.transliteration.text) ? w.transliteration.text : "",
          meaning: (w.translation && w.translation.text) ? w.translation.text : "",
          verse_key: verseKey,
          wIndexInVerse: wIndex,
          wCountInVerse: count
        });
      }
    }
    // Add global counters
    const total = out.length;
    out.forEach((x,i) => {
      x.globalIndex = i+1;
      x.globalTotal = total;
    });
    return out;
  }

  function render(){
    const cur = wordsFlat[idx];
    if(!cur){
      wordEl.textContent = "‚úì";
      pronEl.textContent = "";
      meanEl.textContent = "";
      cornerRef.textContent = `${chapterNumber}:end`;
      cornerProg.textContent = `done`;
      saveProgress();
      return;
    }
  if (inVersePause) {
    document.body.classList.add("resting");
    const k = getVerseKey(cur);

    // Show Arabic verse (smaller) and the full English translation centered
    wordEl.style.display = "block";
    wordEl.textContent = verseTextByKey[k] || cur.arabic || "‚Ä¶";
    wordEl.style.fontSize = "34px";
    wordEl.style.lineHeight = "1.4";

    fullMeanEl.style.display = "block";
    fullMeanEl.textContent = verseEngByKey[k] || verseTextByKey[k] || cur.arabic || "‚Ä¶";
    fullMeanEl.style.fontSize = "20px";
    fullMeanEl.style.lineHeight = "1.5";
    fullMeanEl.style.textAlign = "center";

    // Also show a subtle English hint in the hint area (more transparent)
    if (hintEl) {
      // Hide the bottom hint so we don't repeat the translation
      hintEl.style.display = "none";
    }

    // Hide per-word aids and toggle buttons during the verse pause (including audio)
    pronEl.style.display = "none";
    meanEl.style.display = "none";
    tglPron.style.display = "none";
    tglMean.style.display = "none";
    tglAudio.style.display = "none";

    // Center the corner reference horizontally while paused
    corner.style.left = "50%";
    corner.style.transform = "translateX(-50%)";
    corner.style.top = "8px";

    saveProgress();
    return;
  }

  // Normal word mode
 
   document.body.classList.remove("resting");
   // Restore normal display
   wordEl.style.display = "block";
   fullMeanEl.style.display = "none";

   wordEl.textContent = cur.arabic || "‚Ä¶";
   wordEl.style.fontSize = "56px";
   wordEl.style.lineHeight = "1.25";
    cornerRef.textContent = cur.verse_key;
    cornerProg.textContent = `${cur.globalIndex}/${cur.globalTotal}`;

   // Restore toggle buttons and per-word aids (allow CSS to control display)
   tglPron.style.display = "";
   tglMean.style.display = "";

   // Restore audio toggle
   tglAudio.style.display = "";

   // Restore hint text
   if (hintEl) {
     hintEl.textContent = "Tap/click anywhere to reveal the next word";
     hintEl.style.color = '';
     hintEl.style.display = "";
   }

   // Per-word assistant texts
   pronEl.style.display = showPron ? "block" : "none";
   meanEl.style.display = showMean ? "block" : "none";
   const pronText = showPron ? (cur.translit || "‚Äî") : "";
   const meanText = showMean ? (cur.meaning || getApproxMeaning(cur) || "‚Äî") : "";
   pronEl.textContent = pronText;
   meanEl.textContent = meanText;

   // Debug state after render in normal mode
   console.debug('render normal', { idx, showPron, pronText: pronText, showMean, meanText: meanText, fallbackUsed: !!(showMean && !cur.meaning) });

   // Restore corner position
   corner.style.left = "14px";
   corner.style.transform = "none";
   corner.style.top = "14px";

   saveProgress();
  }

function nextWord(){
  if(!started) return;

  const cur = wordsFlat[idx];
  if (!cur) return;

  // If we're currently resting on the verse, next tap moves on
  if (inVersePause) {
    inVersePause = false;
    render();
    // Now actually advance to the next word (first of next verse)
    idx = Math.min(idx + 1, wordsFlat.length);
    render();
    const now = wordsFlat[idx];
    if (now) speakArabic(now.arabic);
    return;
  }

  // Look ahead: if next word is in a different verse (or doesn't exist), we pause
  const next = wordsFlat[idx + 1];
  const isEndOfVerse = (!next) || (next.verse_key !== cur.verse_key);

  if (isEndOfVerse) {
    inVersePause = true;
    render();          // show the full verse
    return;            // do NOT advance yet
  }

  // Normal advance within verse
  idx += 1;
  render();
  const now = wordsFlat[idx];
  if (now) speakArabic(now.arabic);
}

  function togglePron(ev){
    ev.stopPropagation();
    showPron = !showPron;
    console.debug('togglePron ->', showPron, 'idx=', idx, 'translit=', (wordsFlat[idx] && wordsFlat[idx].translit));
    render();
    saveProgress();
  }
  function toggleMean(ev){
    ev.stopPropagation();
    showMean = !showMean;
    console.debug('toggleMean ->', showMean, 'idx=', idx, 'meaning=', (wordsFlat[idx] && wordsFlat[idx].meaning));
    render();
    saveProgress();
  }

  async function init(chNum){
    // Accept caller-provided chapter; otherwise choose randomly.
    chapterNumber = (chNum !== undefined && chNum !== null) ? chNum : cryptoRandomInt(1,114);
    splashLine.textContent = `Loading Surah ${chapterNumber}‚Ä¶`;
    wordsFlat = [];
    idx = 0;
    inVersePause = false;
    started = false;

    const verses = await fetchAllVersesByChapter(chapterNumber);

    // Prefer verse-level translations if provided by the API
    // Use temporary arrays (parts) to avoid mixing strings and arrays (which caused `.push` on string errors)
    const verseTextParts = {};
    const verseEngParts = {};

    for (const v of verses) {
      const k = v.verse_key || `${v.chapter_id}:${v.verse_number}`;
      // Arabic words (keep as array parts)
      const words = Array.isArray(v.words) ? v.words.map(w => w.text_uthmani || "").filter(Boolean) : [];
      if (words.length) verseTextParts[k] = (verseTextParts[k] ?? []).concat(words);

      // Try verse-level translations first (API sometimes provides `translations` or `translation` fields)
      let eng = "";
      if (v.translations && v.translations.length) {
        eng = v.translations.map(t => t.text || "").join(" ");
      } else if (v.translation && v.translation.text) {
        eng = v.translation.text;
      } else if (v.translated_text) {
        eng = v.translated_text;
      }
      if (eng) verseEngParts[k] = (verseEngParts[k] ?? []).concat(sanitizeEnglish(eng));
    }

    // Flatten words for word-by-word navigation
    wordsFlat = flattenWords(verses);

    // For any verse that lacks a verse-level English text, fall back to joining per-word meanings
    for (const w of wordsFlat) {
      const k = getVerseKey(w);
      if (!k) continue;
      // Only build Arabic fallback if we didn't already collect the verse words
      const hasVerseText = Array.isArray(verseTextParts[k]) && verseTextParts[k].length > 0;
      if (!hasVerseText) {
        verseTextParts[k] = (verseTextParts[k] ?? []).concat(w.arabic);
      }
      if (!verseEngParts[k]) verseEngParts[k] = [];
      if (!verseEngParts[k].length) verseEngParts[k].push(sanitizeEnglish(w.meaning));
    }

    // Finalize maps into joined strings
    verseTextByKey = {};
    verseEngByKey = {};
    for (const k in verseTextParts) {
      verseTextByKey[k] = Array.isArray(verseTextParts[k]) ? verseTextParts[k].join(" ") : String(verseTextParts[k] || "");
    }
    for (const k in verseEngParts) {
      verseEngByKey[k] = sanitizeEnglish(Array.isArray(verseEngParts[k]) ? verseEngParts[k].join(" ").replace(/\s+/g, " ").trim() : String(verseEngParts[k] || ""));
    }

    splashLine.textContent = `Ready. Surah ${chapterNumber} ¬∑ ${wordsFlat.length} words`;
  }

function arabicForTTS(text) {
  return text
    // Remove tatweel
    .replace(/\u0640/g, "")

    // Remove Arabic harakat (diacritics)
    .replace(/[\u064B-\u065F\u0670]/g, "")

    // Remove Qur'anic annotation marks (common ranges)
    // - Arabic small high ligatures & Quranic signs often live here:
    .replace(/[\u06D6-\u06ED]/g, "")

    // Optional: remove Arabic punctuation-like marks if your engine chokes on them
    .replace(/[€ù€û€©]/g, "")

    // Normalize extra whitespace
    .replace(/\s+/g, " ")

	.replace(/\u064C/g, "")
    .trim();
	}

// Strip any HTML/footnote content starting at the first '<' and normalize whitespace
function sanitizeEnglish(s) {
  return String(s || "").replace(/<([\s\S]*)$/g, "").replace(/\s+/g, " ").trim();
}

// Approximate a per-word English meaning by mapping word position in the verse
function getApproxMeaning(cur) {
  try {
    const k = cur && cur.verse_key;
    const verse = (k && verseEngByKey[k]) ? String(verseEngByKey[k]) : "";
    if (!verse) return "";
    const engWords = verse.split(/\s+/).filter(Boolean);
    if (engWords.length === 0) return "";
    const wIndex = Number(cur.wIndexInVerse || 1);
    const wCount = Number(cur.wCountInVerse || 1);
    // Map position proportionally
    const pos = wCount > 1 ? (wIndex - 1) / (wCount - 1) : 0;
    const idx = Math.max(0, Math.min(engWords.length - 1, Math.round(pos * (engWords.length - 1))));
    // Return a small window for context
    const start = Math.max(0, idx - 1);
    const end = Math.min(engWords.length, idx + 2);
    return sanitizeEnglish(engWords.slice(start, end).join(" "));
  } catch (e) {
    return "";
  }
}

  function start(startIndex = 0){
    started = true;
    inVersePause = false;
    idx = clampIndex(startIndex);
    startBtn.dataset.mode = "default";
    showScreen("reader");
    syncAudioToggleVisual();
    render();
    const cur = wordsFlat[idx];
    if (cur) speakArabic(cur.arabic);
  }

  async function loadAndStartSurah(chapter, startAtIndex = 0){
    showScreen("splash");
    bar.style.width = "0%";
    startBtn.dataset.mode = "default";
    startBtn.textContent = "Start";
    startBtn.onclick = null;
    splashLine.textContent = `Loading Surah ${chapter}‚Ä¶`;
    try{
      await init(chapter);
      start(startAtIndex);
    } catch(e){
      splashLine.innerHTML = `<span class="err">Couldn't load the surah (${String(e.message || e)}).</span><br><span class="small">You need an internet connection, and the API must allow your browser (CORS).</span>`;
      startBtn.textContent = "Back to Library";
      startBtn.dataset.mode = "back-to-library";
      startBtn.onclick = (ev) => { ev.stopPropagation(); showScreen("library"); };
      console.error(e);
    }
  }

  function startRandom(){
    const ch = cryptoRandomInt(1,114);
    loadAndStartSurah(ch, 0);
  }

  function startContinue(){
    if(Number.isFinite(savedSurahNumber)){
      loadAndStartSurah(savedSurahNumber, clampIndex(savedWordIndex || 0));
    } else {
      startRandom();
    }
  }

  function startRange(min, max){
    const minNum = Number(min);
    const maxNum = Number(max);
    if(Number.isFinite(minNum) && Number.isFinite(maxNum) && maxNum >= minNum){
      const ch = cryptoRandomInt(minNum, maxNum);
      loadAndStartSurah(ch, 0);
    } else {
      startRandom();
    }
  }

  function openFavorites(){ alert("Favorites coming soon."); }
  function openJournal(){ alert("Journal coming soon."); }
  function openSettings(){ alert("Settings coming soon."); }

  // Events
  // Use a single pointer handler to avoid mobile double-fire (touchstart+click)
  document.addEventListener("pointerdown", () => nextWord());

  // Prevent pointer events on controls from bubbling to the document
  const stopAnd = (fn) => (ev) => { ev.stopPropagation(); fn(ev); };
  tglPron.addEventListener("pointerdown", stopAnd(togglePron));
  tglMean.addEventListener("pointerdown", stopAnd(toggleMean));
  tglAudio.addEventListener("pointerdown", stopAnd(toggleAudio));
  startBtn.addEventListener("pointerdown", (ev) => {
    ev.stopPropagation();
    const mode = startBtn.dataset.mode || "default";
    if(mode === "back-to-library"){
      showScreen("library");
      return;
    }
    if(wordsFlat.length){
      start(idx);
    } else {
      startRandom();
    }
  });

  // Boot
  (async () => {
    syncAudioToggleVisual();
    startBtn.dataset.mode = "default";
    splashLine.textContent = "Select a surah to begin.";
    showScreen("library");
  })();
})();
</script>
</body>
</html>
